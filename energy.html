<!DOCTYPE html
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy-Efficient CPU Scheduling Simulator</title>
    <style>
        :root {
            --primary: #6e48aa;
            --secondary: #9d50bb;
            --accent: #4776e6;
            --text: #f0f0f0;
            --bg: #121212;
            --card-bg: #1e1e1e;
            --highlight: #00ffaa;
            --warning: #ff6b6b;
            --success: #4caf50;
            --info: #2196f3;
        }

        [data-theme="light"] {
            --primary: #7b5cb3;
            --secondary: #a371d1;
            --accent: #5d8aff;
            --text: #333333;
            --bg: #f5f5f5;
            --card-bg: #ffffff;
            --highlight: #008c6a;
            --warning: #ff3d3d;
            --success: #2e7d32;
            --info: #1976d2;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: background-color 0.3s, color 0.3s;
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            background: linear-gradient(90deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-size: 2.5rem;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .theme-toggle {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }

        .theme-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--card-bg);
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: var(--highlight);
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--card-bg);
        }

        input:checked + .slider:before {
            transform: translateX(30px);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
        }

        .panel {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .panel-title {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: var(--highlight);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-title svg {
            width: 20px;
            height: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        input, select {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background-color: rgba(255, 255, 255, 0.05);
            color: var(--text);
            outline: none;
        }

        input:focus, select:focus {
            border-color: var(--accent);
        }

        button {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        button.secondary {
            background: transparent;
            border: 1px solid var(--accent);
        }

        button.warning {
            background: var(--warning);
        }

        button.success {
            background: var(--success);
        }

        button.info {
            background: var(--info);
        }

        .process-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .process-table th, .process-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .process-table th {
            background-color: rgba(0, 0, 0, 0.2);
        }

        .process-table tr:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .gantt-chart {
            margin-top: 20px;
            overflow-x: auto;
            padding-bottom: 20px;
        }

        .gantt-container {
            display: flex;
            height: 100px;
            align-items: center;
            position: relative;
            margin-top: 40px;
        }

        .gantt-bar {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            position: relative;
            border-radius: 4px;
            transition: all 0.3s;
            cursor: pointer;
        }

        .gantt-bar:hover {
            transform: scaleY(1.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .gantt-time {
            position: absolute;
            top: -25px;
            font-size: 0.8rem;
        }

        .gantt-idle {
            background-color: var(--card-bg);
            border: 1px dashed rgba(255, 255, 255, 0.2);
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .metric-card {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid var(--accent);
        }

        .metric-title {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .energy-value {
            color: var(--highlight);
        }

        .comparison-chart {
            margin-top: 30px;
            height: 250px;
            position: relative;
        }

        .chart-bar {
            position: absolute;
            bottom: 0;
            width: 40%;
            transition: height 0.5s ease-in-out;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            color: white;
            font-weight: bold;
            padding-bottom: 10px;
        }

        .chart-bar.traditional {
            left: 5%;
            background-color: var(--warning);
            height: 0;
        }

        .chart-bar.efficient {
            left: 55%;
            background-color: var(--success);
            height: 0;
        }

        .chart-labels {
            position: absolute;
            bottom: -25px;
            width: 100%;
            display: flex;
            justify-content: space-around;
        }

        .chart-label {
            width: 40%;
            text-align: center;
        }

        .tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            position: relative;
        }

        .tab.active {
            color: var(--highlight);
        }

        .tab.active:after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--highlight);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .code-block {
            background-color: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            line-height: 1.5;
            overflow-x: auto;
        }

        .tooltip {
            position: relative;
            display: inline-block;
            border-bottom: 1px dotted var(--text);
            cursor: help;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: var(--card-bg);
            color: var(--text);
            text-align: center;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--accent);
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speed-control label {
            margin-bottom: 0;
            white-space: nowrap;
        }

        .speed-control input {
            width: 100px;
        }

        .process-details {
            margin-top: 20px;
        }

        .process-details table {
            width: 100%;
            border-collapse: collapse;
        }

        .process-details th, .process-details td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .process-details th {
            background-color: rgba(0, 0, 0, 0.2);
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }

        .algorithm-info {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 5px;
            border-left: 3px solid var(--info);
        }

        .algorithm-info h4 {
            margin-bottom: 10px;
            color: var(--info);
        }

        .energy-levels {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .energy-level {
            flex: 1;
            text-align: center;
            padding: 5px;
            border-radius: 3px;
            font-size: 0.8rem;
        }

        .energy-low {
            background-color: #4caf50;
        }

        .energy-medium {
            background-color: #ffc107;
            color: #333;
        }

        .energy-high {
            background-color: #f44336;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: 10px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 1.5rem;
            color: var(--highlight);
        }

        .close-modal {
            background: none;
            border: none;
            color: var(--text);
            font-size: 1.5rem;
            cursor: pointer;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .metrics {
                grid-template-columns: 1fr;
            }

            .header {
                flex-direction: column;
                gap: 15px;
            }

            .header-controls {
                width: 100%;
                justify-content: space-between;
            }

            .btn-group {
                flex-direction: column;
            }

            .btn-group button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Energy-Efficient CPU Scheduling Simulator</h1>
            <div class="header-controls">
                <div class="speed-control">
                    <label for="simulationSpeed">Simulation Speed:</label>
                    <input type="range" id="simulationSpeed" min="100" max="2000" value="1000" step="100">
                    <span id="speedValue">1x</span>
                </div>
                <label class="theme-toggle">
                    <input type="checkbox" id="themeToggle">
                    <span class="slider"></span>
                </label>
            </div>
        </header>

        <div class="main-content">
            <div class="panel">
                <h2 class="panel-title">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
                    </svg>
                    Process Configuration
                </h2>
                
                <div class="form-group">
                    <label for="algorithm">Scheduling Algorithm</label>
                    <select id="algorithm">
                        <option value="fcfs">Energy-Aware FCFS</option>
                        <option value="dvs">Dynamic Voltage Scaling</option>
                        <option value="rr">Energy-Conscious Round Robin</option>
                        <option value="sjf">Power-Saving SJF</option>
                        <option value="eas">Energy-Aware Scheduling (EAS)</option>
                        <option value="dvfs">DVFS Scheduling</option>
                    </select>
                </div>
                
                <div class="form-group" id="quantumGroup">
                    <label for="quantum">Time Quantum (for RR)</label>
                    <input type="number" id="quantum" value="2" min="1">
                </div>
                
                <div class="form-group">
                    <label for="pid">Process ID</label>
                    <input type="text" id="pid" placeholder="P1">
                </div>
                
                <div class="form-group">
                    <label for="arrival">Arrival Time</label>
                    <input type="number" id="arrival" value="0" min="0">
                </div>
                
                <div class="form-group">
                    <label for="burst">Burst Time</label>
                    <input type="number" id="burst" value="1" min="1">
                </div>
                
                <div class="form-group">
                    <label for="energy">Energy Consumption (W)</label>
                    <input type="number" id="energy" value="10" min="1" step="0.1">
                </div>
                
                <div class="form-group">
                    <label for="priority">Priority (1-10, 1=highest)</label>
                    <input type="number" id="priority" value="5" min="1" max="10">
                </div>
                
                <div class="energy-levels">
                    <div class="energy-level energy-low">Low (1-5W)</div>
                    <div class="energy-level energy-medium">Medium (6-15W)</div>
                    <div class="energy-level energy-high">High (16+W)</div>
                </div>
                
                <div class="btn-group">
                    <button id="addProcess" class="success">Add Process</button>
                    <button id="generateRandom" class="info">Generate Random</button>
                    <button id="clearProcesses" class="warning">Clear All</button>
                </div>
                
                <table class="process-table">
                    <thead>
                        <tr>
                            <th>PID</th>
                            <th>Arrival</th>
                            <th>Burst</th>
                            <th>Energy</th>
                            <th>Priority</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody id="processTableBody"></tbody>
                </table>
                
                <div class="btn-group" style="margin-top: 20px;">
                    <button id="startSimulation" class="success">Start Simulation</button>
                    <button id="pauseSimulation" class="secondary" disabled>Pause</button>
                    <button id="resetSimulation" class="secondary">Reset</button>
                </div>
                
                <div class="btn-group">
                    <button id="exportCSV" class="info">Export CSV</button>
                    <button id="saveProcesses" class="secondary">Save Processes</button>
                    <button id="loadProcesses" class="secondary">Load Processes</button>
                </div>
            </div>
            
            <div class="panel">
                <div class="tabs">
                    <div class="tab active" data-tab="simulation">Simulation</div>
                    <div class="tab" data-tab="metrics">Metrics</div>
                    <div class="tab" data-tab="algorithm">Algorithm</div>
                    <div class="tab" data-tab="comparison">Comparison</div>
                </div>
                
                <div class="tab-content active" id="simulationTab">
                    <h2 class="panel-title">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
                            <line x1="8" y1="21" x2="16" y2="21"></line>
                            <line x1="12" y1="17" x2="12" y2="21"></line>
                        </svg>
                        Gantt Chart
                    </h2>
                    
                    <div class="legend" id="ganttLegend"></div>
                    
                    <div class="gantt-chart">
                        <div id="ganttContainer" class="gantt-container"></div>
                    </div>
                    
                    <div id="processDetails" style="margin-top: 20px;"></div>
                </div>
                
                <div class="tab-content" id="metricsTab">
                    <h2 class="panel-title">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="12" y1="20" x2="12" y2="10"></line>
                            <line x1="18" y1="20" x2="18" y2="4"></line>
                            <line x1="6" y1="20" x2="6" y2="16"></line>
                        </svg>
                        Performance Metrics
                    </h2>
                    
                    <div class="metrics">
                        <div class="metric-card">
                            <div class="metric-title">Total Energy Consumption</div>
                            <div class="metric-value energy-value" id="totalEnergy">0 W</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-title">CPU Utilization</div>
                            <div class="metric-value" id="cpuUtilization">0%</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-title">Idle Time</div>
                            <div class="metric-value" id="idleTime">0 units</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-title">Avg. Turnaround Time</div>
                            <div class="metric-value" id="avgTurnaround">0</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-title">Avg. Waiting Time</div>
                            <div class="metric-value" id="avgWaiting">0</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-title">Throughput</div>
                            <div class="metric-value" id="throughput">0</div>
                        </div>
                    </div>
                    
                    <h3 class="panel-title" style="margin-top: 30px;">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                        </svg>
                        Process Completion Details
                    </h3>
                    
                    <div id="processMetrics" class="process-details"></div>
                </div>
                
                <div class="tab-content" id="algorithmTab">
                    <h2 class="panel-title">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="16 18 22 12 16 6"></polyline>
                            <polyline points="8 6 2 12 8 18"></polyline>
                        </svg>
                        Algorithm Details
                    </h2>
                    
                    <div id="algorithmDetails">
                        <div class="algorithm-info">
                            <h4>Energy-Efficient Scheduling Concepts</h4>
                            <p>Energy-efficient CPU scheduling aims to reduce power consumption while maintaining system performance. Techniques include:</p>
                            <ul>
                                <li><strong>Dynamic Voltage and Frequency Scaling (DVFS):</strong> Adjusts CPU voltage and frequency based on workload.</li>
                                <li><strong>Energy-Aware Scheduling (EAS):</strong> Considers both performance and energy consumption when making scheduling decisions.</li>
                                <li><strong>Load Balancing:</strong> Distributes tasks to maximize energy efficiency across cores.</li>
                                <li><strong>Idle State Optimization:</strong> Puts CPU cores into low-power states during idle periods.</li>
                            </ul>
                        </div>
                        
                        <div id="algorithmSpecificInfo"></div>
                    </div>
                </div>
                
                <div class="tab-content" id="comparisonTab">
                    <h2 class="panel-title">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                        </svg>
                        Algorithm Comparison
                    </h2>
                    
                    <div class="btn-group">
                        <button id="compareAlgorithms" class="info">Run Comparison</button>
                        <button id="clearComparison" class="secondary">Clear Results</button>
                    </div>
                    
                    <div id="comparisonResults" style="margin-top: 20px;"></div>
                    
                    <div class="comparison-chart">
                        <div class="chart-bar traditional" id="traditionalBar"></div>
                        <div class="chart-bar efficient" id="efficientBar"></div>
                        <div class="chart-labels">
                            <div class="chart-label">Traditional</div>
                            <div class="chart-label">Energy-Efficient</div>
                        </div>
                    </div>
                    
                    <div id="comparisonMetrics" style="margin-top: 40px;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for random process generation -->
    <div class="modal" id="randomProcessModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Generate Random Processes</h3>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="randomCount">Number of Processes</label>
                    <input type="number" id="randomCount" value="5" min="1" max="20">
                </div>
                <div class="form-group">
                    <label for="maxBurst">Max Burst Time</label>
                    <input type="number" id="maxBurst" value="10" min="1">
                </div>
                <div class="form-group">
                    <label for="maxEnergy">Max Energy Consumption</label>
                    <input type="number" id="maxEnergy" value="20" min="1" step="0.1">
                </div>
                <div class="form-group">
                    <label for="maxArrival">Max Arrival Time</label>
                    <input type="number" id="maxArrival" value="10" min="0">
                </div>
            </div>
            <div class="modal-footer">
                <button class="secondary" id="cancelRandom">Cancel</button>
                <button class="success" id="generateRandomProcesses">Generate</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Theme toggle
            const themeToggle = document.getElementById('themeToggle');
            themeToggle.addEventListener('change', function() {
                document.body.setAttribute('data-theme', this.checked ? 'light' : 'dark');
            });
            
            // Speed control
            const speedControl = document.getElementById('simulationSpeed');
            const speedValue = document.getElementById('speedValue');
            speedControl.addEventListener('input', function() {
                simulationSpeed = 2100 - this.value; // Invert so faster is to the right
                speedValue.textContent = `${(1000/simulationSpeed).toFixed(1)}x`;
            });
            let simulationSpeed = 2100 - speedControl.value;
            
            // Tab switching
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    // Remove active class from all tabs and content
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding content
                    this.classList.add('active');
                    const tabId = this.getAttribute('data-tab') + 'Tab';
                    document.getElementById(tabId).classList.add('active');
                });
            });
            
            // Show/hide quantum input based on algorithm
            document.getElementById('algorithm').addEventListener('change', function() {
                document.getElementById('quantumGroup').style.display = 
                    this.value === 'rr' ? 'block' : 'none';
                updateAlgorithmDetails();
            });
            
            // Process management
            let processes = [];
            const processTableBody = document.getElementById('processTableBody');
            
            document.getElementById('addProcess').addEventListener('click', function() {
                const pid = document.getElementById('pid').value || `P${processes.length + 1}`;
                const arrival = parseInt(document.getElementById('arrival').value);
                const burst = parseInt(document.getElementById('burst').value);
                const energy = parseFloat(document.getElementById('energy').value);
                const priority = parseInt(document.getElementById('priority').value);
                
                if (burst <= 0) {
                    alert('Burst time must be positive');
                    return;
                }
                
                if (energy <= 0) {
                    alert('Energy consumption must be positive');
                    return;
                }
                
                if (priority < 1 || priority > 10) {
                    alert('Priority must be between 1 and 10');
                    return;
                }
                
                processes.push({
                    pid,
                    arrival,
                    burst,
                    energy,
                    priority,
                    remaining: burst,
                    completed: false,
                    startTime: null,
                    endTime: null,
                    waitingTime: 0
                });
                
                updateProcessTable();
                
                // Clear inputs
                document.getElementById('pid').value = '';
                document.getElementById('arrival').value = arrival + 1;
                document.getElementById('burst').value = 1;
                document.getElementById('priority').value = 5;
            });
            
            document.getElementById('clearProcesses').addEventListener('click', function() {
                if (processes.length > 0 && confirm('Are you sure you want to clear all processes?')) {
                    processes = [];
                    updateProcessTable();
                }
            });
            
            // Random process generation
            document.getElementById('generateRandom').addEventListener('click', function() {
                document.getElementById('randomProcessModal').style.display = 'flex';
            });
            
            document.querySelector('.close-modal').addEventListener('click', function() {
                document.getElementById('randomProcessModal').style.display = 'none';
            });
            
            document.getElementById('cancelRandom').addEventListener('click', function() {
                document.getElementById('randomProcessModal').style.display = 'none';
            });
            
            document.getElementById('generateRandomProcesses').addEventListener('click', function() {
                const count = parseInt(document.getElementById('randomCount').value);
                const maxBurst = parseInt(document.getElementById('maxBurst').value);
                const maxEnergy = parseFloat(document.getElementById('maxEnergy').value);
                const maxArrival = parseInt(document.getElementById('maxArrival').value);
                
                if (count <= 0 || maxBurst <= 0 || maxEnergy <= 0 || maxArrival < 0) {
                    alert('All values must be positive');
                    return;
                }
                
                // Clear existing processes
                processes = [];
                
                // Generate random processes
                for (let i = 0; i < count; i++) {
                    processes.push({
                        pid: `P${i+1}`,
                        arrival: Math.floor(Math.random() * (maxArrival + 1)),
                        burst: Math.max(1, Math.floor(Math.random() * maxBurst) + 1),
                        energy: Math.max(1, (Math.random() * maxEnergy).toFixed(1)),
                        priority: Math.max(1, Math.min(10, Math.floor(Math.random() * 10) + 1)),
                        remaining: 0,
                        completed: false,
                        startTime: null,
                        endTime: null,
                        waitingTime: 0
                    });
                    
                    // Set remaining time after creating the object
                    processes[i].remaining = processes[i].burst;
                }
                
                updateProcessTable();
                document.getElementById('randomProcessModal').style.display = 'none';
            });
            
            function updateProcessTable() {
                processTableBody.innerHTML = '';
                
                processes.forEach((process, index) => {
                    const row = document.createElement('tr');
                    
                    row.innerHTML = `
                        <td>${process.pid}</td>
                        <td>${process.arrival}</td>
                        <td>${process.burst}</td>
                        <td>${process.energy}W</td>
                        <td>${process.priority}</td>
                        <td><button class="delete-process" data-index="${index}">Delete</button></td>
                    `;
                    
                    processTableBody.appendChild(row);
                });
                
                // Add event listeners to delete buttons
                document.querySelectorAll('.delete-process').forEach(button => {
                    button.addEventListener('click', function() {
                        const index = parseInt(this.getAttribute('data-index'));
                        processes.splice(index, 1);
                        updateProcessTable();
                    });
                });
            }
            
            // Simulation
            let simulationInterval;
            let currentTime = 0;
            let isSimulationRunning = false;
            let ganttData = [];
            let totalEnergy = 0;
            let cpuBusyTime = 0;
            let cpuIdleTime = 0;
            let lastProcess = null;
            let currentAlgorithm = '';
            
            document.getElementById('startSimulation').addEventListener('click', startSimulation);
            document.getElementById('pauseSimulation').addEventListener('click', pauseSimulation);
            document.getElementById('resetSimulation').addEventListener('click', resetSimulation);
            
            function startSimulation() {
                if (processes.length === 0) {
                    alert('Please add at least one process');
                    return;
                }
                
                if (isSimulationRunning) return;
                
                isSimulationRunning = true;
                document.getElementById('startSimulation').disabled = true;
                document.getElementById('pauseSimulation').disabled = false;
                
                // Reset metrics
                currentTime = 0;
                totalEnergy = 0;
                cpuBusyTime = 0;
                cpuIdleTime = 0;
                ganttData = [];
                lastProcess = null;
                
                // Make a copy of processes for simulation
                const simProcesses = JSON.parse(JSON.stringify(processes));
                simProcesses.forEach(p => {
                    p.remaining = p.burst;
                    p.completed = false;
                    p.startTime = null;
                    p.endTime = null;
                    p.waitingTime = 0;
                });
                
                // Get selected algorithm
                currentAlgorithm = document.getElementById('algorithm').value;
                const quantum = parseInt(document.getElementById('quantum').value);
                
                simulationInterval = setInterval(() => {
                    currentTime++;
                    
                    // Update waiting times for all arrived but not running processes
                    simProcesses.forEach(p => {
                        if (!p.completed && p.arrival <= currentTime && 
                            (!lastProcess || p.pid !== lastProcess.pid)) {
                            p.waitingTime++;
                        }
                    });
                    
                    // Run one step of the selected algorithm
                    let currentProcess = null;
                    
                    switch (currentAlgorithm) {
                        case 'fcfs':
                            currentProcess = runFCFS(simProcesses, currentTime);
                            break;
                        case 'dvs':
                            currentProcess = runDVS(simProcesses, currentTime);
                            break;
                        case 'rr':
                            currentProcess = runRoundRobin(simProcesses, currentTime, quantum);
                            break;
                        case 'sjf':
                            currentProcess = runSJF(simProcesses, currentTime);
                            break;
                        case 'eas':
                            currentProcess = runEAS(simProcesses, currentTime);
                            break;
                        case 'dvfs':
                            currentProcess = runDVFS(simProcesses, currentTime);
                            break;
                    }
                    
                    // Record start time if this is the first time the process is running
                    if (currentProcess && currentProcess.startTime === null) {
                        currentProcess.startTime = currentTime;
                    }
                    
                    // Update Gantt chart
                    if (currentProcess) {
                        ganttData.push({
                            time: currentTime,
                            process: currentProcess.pid,
                            energy: currentProcess.energy,
                            algorithm: currentAlgorithm
                        });
                        
                        totalEnergy += currentProcess.energy;
                        cpuBusyTime++;
                        lastProcess = currentProcess;
                        
                        // Record completion time if process just finished
                        if (currentProcess.remaining === 0) {
                            currentProcess.endTime = currentTime;
                            currentProcess.turnaround = currentProcess.endTime - currentProcess.arrival;
                            currentProcess.waiting = currentProcess.waitingTime;
                        }
                    } else {
                        ganttData.push({
                            time: currentTime,
                            process: 'IDLE',
                            energy: 0,
                            algorithm: currentAlgorithm
                        });
                        
                        cpuIdleTime++;
                        lastProcess = null;
                    }
                    
                    updateGanttChart();
                    updateMetrics(simProcesses);
                    
                    // Check if all processes are completed
                    const allCompleted = simProcesses.every(p => p.completed);
                    if (allCompleted) {
                        pauseSimulation();
                        showComparisonChart(simProcesses);
                        updateProcessMetrics(simProcesses);
                    }
                    
                }, simulationSpeed);
            }
            
            function pauseSimulation() {
                clearInterval(simulationInterval);
                isSimulationRunning = false;
                document.getElementById('startSimulation').disabled = false;
                document.getElementById('pauseSimulation').disabled = true;
            }
            
            function resetSimulation() {
                pauseSimulation();
                currentTime = 0;
                ganttData = [];
                totalEnergy = 0;
                cpuBusyTime = 0;
                cpuIdleTime = 0;
                
                document.getElementById('ganttContainer').innerHTML = '';
                document.getElementById('processDetails').innerHTML = '';
                document.getElementById('ganttLegend').innerHTML = '';
                updateMetrics([]);
                document.getElementById('processMetrics').innerHTML = '';
                
                // Reset comparison chart
                document.getElementById('traditionalBar').style.height = '0';
                document.getElementById('efficientBar').style.height = '0';
            }
            
            // Scheduling algorithms
            function runFCFS(processes, currentTime) {
                // Find the first arrived process that hasn't completed yet
                const process = processes.find(p => 
                    !p.completed && p.arrival <= currentTime
                );
                
                if (!process) return null;
                
                process.remaining--;
                
                if (process.remaining === 0) {
                    process.completed = true;
                }
                
                return process;
            }
            
            function runDVS(processes, currentTime) {
                // Similar to FCFS but with dynamic voltage scaling
                const process = processes.find(p => 
                    !p.completed && p.arrival <= currentTime
                );
                
                if (!process) return null;
                
                // Reduce energy consumption when process has high remaining time
                const energyFactor = Math.min(1, process.remaining / process.burst + 0.2);
                const adjustedEnergy = process.energy * energyFactor;
                
                process.remaining--;
                
                if (process.remaining === 0) {
                    process.completed = true;
                }
                
                // Return a copy with adjusted energy for this time unit
                return {
                    ...process,
                    energy: adjustedEnergy
                };
            }
            
            function runRoundRobin(processes, currentTime, quantum) {
                // Find all arrived, incomplete processes
                const readyQueue = processes.filter(p => 
                    !p.completed && p.arrival <= currentTime
                );
                
                if (readyQueue.length === 0) return null;
                
                // Get the next process in queue
                const processIndex = processes.findIndex(p => p.pid === readyQueue[0].pid);
                const process = processes[processIndex];
                
                // Execute for this time unit
                process.remaining--;
                
                if (process.remaining === 0) {
                    process.completed = true;
                }
                
                // Rotate queue if process isn't completed and there are other processes
                if (!process.completed && readyQueue.length > 1) {
                    processes.splice(processIndex, 1);
                    processes.push(process);
                }
                
                return process;
            }
            
            function runSJF(processes, currentTime) {
                // Find the shortest job among arrived, incomplete processes
                const readyQueue = processes.filter(p => 
                    !p.completed && p.arrival <= currentTime
                );
                
                if (readyQueue.length === 0) return null;
                
                // Sort by remaining time (SJF)
                readyQueue.sort((a, b) => a.remaining - b.remaining);
                const process = readyQueue[0];
                
                process.remaining--;
                
                if (process.remaining === 0) {
                    process.completed = true;
                }
                
                return process;
            }
            
            function runEAS(processes, currentTime) {
                // Energy-Aware Scheduling - considers both energy and performance
                const readyQueue = processes.filter(p => 
                    !p.completed && p.arrival <= currentTime
                );
                
                if (readyQueue.length === 0) return null;
                
                // Sort by energy efficiency (lower energy first, then by remaining time)
                readyQueue.sort((a, b) => {
                    const energyDiff = a.energy - b.energy;
                    if (energyDiff !== 0) return energyDiff;
                    return a.remaining - b.remaining;
                });
                
                const process = readyQueue[0];
                process.remaining--;
                
                if (process.remaining === 0) {
                    process.completed = true;
                }
                
                return process;
            }
            
            function runDVFS(processes, currentTime) {
                // Dynamic Voltage and Frequency Scaling - adjusts energy based on load
                const process = processes.find(p => 
                    !p.completed && p.arrival <= currentTime
                );
                
                if (!process) return null;
                
                // Adjust energy based on remaining time and priority
                const loadFactor = process.remaining / process.burst;
                const priorityFactor = 1 - (process.priority - 1) / 9; // Convert 1-10 to 0-1
                
                // More aggressive scaling for lower priority processes
                const energyFactor = 0.3 + (0.7 * loadFactor * priorityFactor);
                const adjustedEnergy = process.energy * energyFactor;
                
                process.remaining--;
                
                if (process.remaining === 0) {
                    process.completed = true;
                }
                
                return {
                    ...process,
                    energy: adjustedEnergy
                };
            }
            
            // Visualization
            function updateGanttChart() {
                const container = document.getElementById('ganttContainer');
                const legend = document.getElementById('ganttLegend');
                container.innerHTML = '';
                legend.innerHTML = '';
                
                // Create a color palette for processes
                const colors = {};
                const colorPalette = [
                    '#6e48aa', '#9d50bb', '#4776e6', '#4ecdc4', 
                    '#a1ffce', '#ff6b6b', '#ffa502', '#7bed9f',
                    '#ff9ff3', '#feca57', '#ff6b6b', '#48dbfb'
                ];
                
                // Add legend items
                processes.forEach((p, i) => {
                    colors[p.pid] = colorPalette[i % colorPalette.length];
                    
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    legendItem.innerHTML = `
                        <div class="legend-color" style="background-color: ${colors[p.pid]}"></div>
                        <span>${p.pid}</span>
                    `;
                    legend.appendChild(legendItem);
                });
                
                // Add IDLE to legend
                const idleLegend = document.createElement('div');
                idleLegend.className = 'legend-item';
                idleLegend.innerHTML = `
                    <div class="legend-color gantt-idle"></div>
                    <span>IDLE</span>
                `;
                legend.appendChild(idleLegend);
                
                // Calculate total time
                const totalTime = ganttData.length;
                if (totalTime === 0) return;
                
                // Calculate bar width based on total time and container width
                const containerWidth = container.offsetWidth;
                const minBarWidth = 30; // Minimum width for visibility
                const maxBars = Math.floor(containerWidth / minBarWidth);
                const displayTime = Math.min(totalTime, maxBars);
                const startIndex = Math.max(0, totalTime - displayTime);
                
                // Add time labels
                for (let i = startIndex; i < totalTime; i++) {
                    const timeLabel = document.createElement('div');
                    timeLabel.className = 'gantt-time';
                    timeLabel.textContent = i;
                    timeLabel.style.left = `${((i - startIndex) / displayTime) * 100}%`;
                    container.appendChild(timeLabel);
                }
                
                // Add bars
                for (let i = startIndex; i < totalTime; i++) {
                    const data = ganttData[i];
                    const bar = document.createElement('div');
                    bar.className = 'gantt-bar';
                    
                    if (data.process === 'IDLE') {
                        bar.classList.add('gantt-idle');
                        bar.textContent = 'IDLE';
                    } else {
                        bar.style.backgroundColor = colors[data.process];
                        bar.textContent = data.process;
                    }
                    
                    bar.style.left = `${((i - startIndex) / displayTime) * 100}%`;
                    bar.style.width = `${(1 / displayTime) * 100}%`;
                    
                    // Tooltip with details
                    const tooltip = document.createElement('div');
                    tooltip.textContent = `Time: ${i}\nProcess: ${data.process}`;
                    if (data.process !== 'IDLE') {
                        tooltip.textContent += `\nEnergy: ${data.energy.toFixed(1)}W`;
                        tooltip.textContent += `\nAlgorithm: ${data.algorithm}`;
                    }
                    bar.title = tooltip.textContent;
                    
                    // Click event for more details
                    bar.addEventListener('click', function() {
                        showProcessDetails(data, i);
                    });
                    
                    container.appendChild(bar);
                }
            }
            
            function showProcessDetails(data, time) {
                const detailsDiv = document.getElementById('processDetails');
                
                if (data.process === 'IDLE') {
                    detailsDiv.innerHTML = `
                        <div class="metric-card">
                            <h3>CPU Idle at Time ${time}</h3>
                            <p>No processes were executing at this time.</p>
                        </div>
                    `;
                } else {
                    const process = processes.find(p => p.pid === data.process);
                    detailsDiv.innerHTML = `
                        <div class="metric-card">
                            <h3>Process ${data.process} at Time ${time}</h3>
                            <p><strong>Arrival Time:</strong> ${process.arrival}</p>
                            <p><strong>Burst Time:</strong> ${process.burst}</p>
                            <p><strong>Priority:</strong> ${process.priority}</p>
                            <p><strong>Energy Consumption:</strong> ${data.energy.toFixed(1)}W</p>
                            ${process.completed && process.endTime <= time ? `
                                <p><strong>Completed at:</strong> ${process.endTime}</p>
                                <p><strong>Turnaround Time:</strong> ${process.turnaround}</p>
                                <p><strong>Waiting Time:</strong> ${process.waiting}</p>
                            ` : `
                                <p><strong>Remaining Time:</strong> ${process.remaining}</p>
                                <p><strong>Status:</strong> ${process.completed ? 'Completed' : 'Running'}</p>
                            `}
                        </div>
                    `;
                }
            }
            
            function updateMetrics(simProcesses) {
                const totalTime = cpuBusyTime + cpuIdleTime;
                const utilization = totalTime > 0 ? (cpuBusyTime / totalTime) * 100 : 0;
                
                // Calculate average turnaround and waiting times
                let avgTurnaround = 0;
                let avgWaiting = 0;
                let completedCount = 0;
                
                if (simProcesses && simProcesses.length > 0) {
                    completedCount = simProcesses.filter(p => p.completed).length;
                    if (completedCount > 0) {
                        avgTurnaround = simProcesses
                            .filter(p => p.completed)
                            .reduce((sum, p) => sum + p.turnaround, 0) / completedCount;
                            
                        avgWaiting = simProcesses
                            .filter(p => p.completed)
                            .reduce((sum, p) => sum + p.waiting, 0) / completedCount;
                    }
                }
                
                // Calculate throughput (processes per unit time)
                const throughput = totalTime > 0 ? (completedCount / totalTime).toFixed(2) : 0;
                
                document.getElementById('totalEnergy').textContent = `${totalEnergy.toFixed(1)} W`;
                document.getElementById('cpuUtilization').textContent = `${utilization.toFixed(1)}%`;
                document.getElementById('idleTime').textContent = `${cpuIdleTime} units`;
                document.getElementById('avgTurnaround').textContent = `${avgTurnaround.toFixed(1)}`;
                document.getElementById('avgWaiting').textContent = `${avgWaiting.toFixed(1)}`;
                document.getElementById('throughput').textContent = `${throughput}`;
            }
            
            function updateProcessMetrics(simProcesses) {
                const metricsDiv = document.getElementById('processMetrics');
                metricsDiv.innerHTML = '';
                
                if (!simProcesses || simProcesses.length === 0) return;
                
                const table = document.createElement('table');
                table.className = 'process-table';
                
                // Create table header
                const thead = document.createElement('thead');
                thead.innerHTML = `
                    <tr>
                        <th>PID</th>
                        <th>Arrival</th>
                        <th>Burst</th>
                        <th>Start</th>
                        <th>End</th>
                        <th>Turnaround</th>
                        <th>Waiting</th>
                        <th>Energy</th>
                    </tr>
                `;
                table.appendChild(thead);
                
                // Create table body
                const tbody = document.createElement('tbody');
                
                simProcesses.forEach(p => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${p.pid}</td>
                        <td>${p.arrival}</td>
                        <td>${p.burst}</td>
                        <td>${p.startTime !== null ? p.startTime : '-'}</td>
                        <td>${p.endTime !== null ? p.endTime : '-'}</td>
                        <td>${p.turnaround !== undefined ? p.turnaround : '-'}</td>
                        <td>${p.waiting !== undefined ? p.waiting : '-'}</td>
                        <td>${(p.energy * p.burst).toFixed(1)}W</td>
                    `;
                    tbody.appendChild(row);
                });
                
                table.appendChild(tbody);
                metricsDiv.appendChild(table);
            }
            
            function showComparisonChart(simProcesses) {
                // Calculate traditional scheduling energy (assuming no optimizations)
                let traditionalEnergy = 0;
                let traditionalTurnaround = 0;
                let traditionalWaiting = 0;
                
                processes.forEach(p => {
                    traditionalEnergy += p.energy * p.burst;
                    
                    if (simProcesses) {
                        const simProcess = simProcesses.find(sp => sp.pid === p.pid);
                        if (simProcess && simProcess.turnaround) {
                            traditionalTurnaround += simProcess.turnaround;
                            traditionalWaiting += simProcess.waiting;
                        }
                    }
                });
                
                if (simProcesses && simProcesses.length > 0) {
                    traditionalTurnaround /= simProcesses.length;
                    traditionalWaiting /= simProcesses.length;
                }
                
                // Calculate max height for comparison
                const maxEnergy = Math.max(traditionalEnergy, totalEnergy);
                const chartHeight = 200; // px
                
                // Animate the bars
                const traditionalBar = document.getElementById('traditionalBar');
                const efficientBar = document.getElementById('efficientBar');
                
                traditionalBar.style.height = `${(traditionalEnergy / maxEnergy) * chartHeight}px`;
                traditionalBar.textContent = `${traditionalEnergy.toFixed(1)}W`;
                
                efficientBar.style.height = `${(totalEnergy / maxEnergy) * chartHeight}px`;
                efficientBar.textContent = `${totalEnergy.toFixed(1)}W`;
                
                // Update comparison metrics
                if (simProcesses) {
                    let avgTurnaround = 0;
                    let avgWaiting = 0;
                    let completedCount = simProcesses.filter(p => p.completed).length;
                    
                    if (completedCount > 0) {
                        avgTurnaround = simProcesses
                            .filter(p => p.completed)
                            .reduce((sum, p) => sum + p.turnaround, 0) / completedCount;
                            
                        avgWaiting = simProcesses
                            .filter(p => p.completed)
                            .reduce((sum, p) => sum + p.waiting, 0) / completedCount;
                    }
                    
                    const comparisonDiv = document.getElementById('comparisonMetrics');
                    comparisonDiv.innerHTML = `
                        <div class="metrics">
                            <div class="metric-card">
                                <div class="metric-title">Energy Savings</div>
                                <div class="metric-value energy-value">${((1 - (totalEnergy / traditionalEnergy)) * 100).toFixed(1)}%</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Turnaround Time Difference</div>
                                <div class="metric-value">${(avgTurnaround - traditionalTurnaround).toFixed(1)}</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Waiting Time Difference</div>
                                <div class="metric-value">${(avgWaiting - traditionalWaiting).toFixed(1)}</div>
                            </div>
                        </div>
                    `;
                }
            }
            
            // Algorithm comparison
            document.getElementById('compareAlgorithms').addEventListener('click', function() {
                if (processes.length === 0) {
                    alert('Please add at least one process');
                    return;
                }
                
                const algorithms = [
                    { id: 'fcfs', name: 'FCFS' },
                    { id: 'sjf', name: 'SJF' },
                    { id: 'rr', name: 'Round Robin' },
                    { id: 'dvs', name: 'DVS' },
                    { id: 'eas', name: 'EAS' },
                    { id: 'dvfs', name: 'DVFS' }
                ];
                
                const results = [];
                const quantum = parseInt(document.getElementById('quantum').value);
                
                // Run simulation for each algorithm
                algorithms.forEach(alg => {
                    // Make a copy of processes
                    const simProcesses = JSON.parse(JSON.stringify(processes));
                    simProcesses.forEach(p => {
                        p.remaining = p.burst;
                        p.completed = false;
                        p.startTime = null;
                        p.endTime = null;
                        p.waitingTime = 0;
                    });
                    
                    let currentTime = 0;
                    let totalEnergy = 0;
                    let ganttData = [];
                    
                    // Simulate until all processes complete
                    while (simProcesses.some(p => !p.completed)) {
                        currentTime++;
                        
                        // Update waiting times
                        simProcesses.forEach(p => {
                            if (!p.completed && p.arrival <= currentTime) {
                                p.waitingTime++;
                            }
                        });
                        
                        // Run one step of the algorithm
                        let currentProcess = null;
                        
                        switch (alg.id) {
                            case 'fcfs':
                                currentProcess = runFCFS(simProcesses, currentTime);
                                break;
                            case 'dvs':
                                currentProcess = runDVS(simProcesses, currentTime);
                                break;
                            case 'rr':
                                currentProcess = runRoundRobin(simProcesses, currentTime, quantum);
                                break;
                            case 'sjf':
                                currentProcess = runSJF(simProcesses, currentTime);
                                break;
                            case 'eas':
                                currentProcess = runEAS(simProcesses, currentTime);
                                break;
                            case 'dvfs':
                                currentProcess = runDVFS(simProcesses, currentTime);
                                break;
                        }
                        
                        // Record start time if first time running
                        if (currentProcess && currentProcess.startTime === null) {
                            currentProcess.startTime = currentTime;
                        }
                        
                        if (currentProcess) {
                            totalEnergy += currentProcess.energy;
                            
                            // Record completion time if process just finished
                            if (currentProcess.remaining === 0) {
                                currentProcess.endTime = currentTime;
                                currentProcess.turnaround = currentProcess.endTime - currentProcess.arrival;
                                currentProcess.waiting = currentProcess.waitingTime;
                            }
                        }
                    }
                    
                    // Calculate metrics
                    const completedProcesses = simProcesses.filter(p => p.completed);
                    const avgTurnaround = completedProcesses.reduce((sum, p) => sum + p.turnaround, 0) / completedProcesses.length;
                    const avgWaiting = completedProcesses.reduce((sum, p) => sum + p.waiting, 0) / completedProcesses.length;
                    const throughput = currentTime > 0 ? (completedProcesses.length / currentTime).toFixed(2) : 0;
                    
                    results.push({
                        name: alg.name,
                        totalEnergy,
                        avgTurnaround,
                        avgWaiting,
                        throughput,
                        totalTime: currentTime
                    });
                });
                
                // Display comparison results
                displayComparisonResults(results);
            });
            
            function displayComparisonResults(results) {
                const comparisonDiv = document.getElementById('comparisonResults');
                comparisonDiv.innerHTML = '';
                
                // Create table
                const table = document.createElement('table');
                table.className = 'process-table';
                
                // Table header
                const thead = document.createElement('thead');
                thead.innerHTML = `
                    <tr>
                        <th>Algorithm</th>
                        <th>Total Energy (W)</th>
                        <th>Avg. Turnaround</th>
                        <th>Avg. Waiting</th>
                        <th>Throughput</th>
                        <th>Total Time</th>
                    </tr>
                `;
                table.appendChild(thead);
                
                // Table body
                const tbody = document.createElement('tbody');
                
                results.forEach(result => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${result.name}</td>
                        <td>${result.totalEnergy.toFixed(1)}</td>
                        <td>${result.avgTurnaround.toFixed(1)}</td>
                        <td>${result.avgWaiting.toFixed(1)}</td>
                        <td>${result.throughput}</td>
                        <td>${result.totalTime}</td>
                    `;
                    
                    // Highlight the most energy-efficient
                    if (result.totalEnergy === Math.min(...results.map(r => r.totalEnergy))) {
                        row.style.backgroundColor = 'rgba(76, 175, 80, 0.2)';
                    }
                    
                    tbody.appendChild(row);
                });
                
                table.appendChild(tbody);
                comparisonDiv.appendChild(table);
            }
            
            document.getElementById('clearComparison').addEventListener('click', function() {
                document.getElementById('comparisonResults').innerHTML = '';
                document.getElementById('comparisonMetrics').innerHTML = '';
                document.getElementById('traditionalBar').style.height = '0';
                document.getElementById('efficientBar').style.height = '0';
            });
            
            // Export functionality
            document.getElementById('exportCSV').addEventListener('click', function() {
                if (ganttData.length === 0) {
                    alert('No simulation data to export');
                    return;
                }
                
                let csvContent = "Time,Process,Energy (W),Algorithm\n";
                
                ganttData.forEach(data => {
                    csvContent += `${data.time},${data.process},${data.energy},${data.algorithm}\n`;
                });
                
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', 'cpu_scheduling_simulation.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });
            
            // Save/load processes
            document.getElementById('saveProcesses').addEventListener('click', function() {
                if (processes.length === 0) {
                    alert('No processes to save');
                    return;
                }
                
                const data = JSON.stringify(processes);
                localStorage.setItem('cpuSchedulerProcesses', data);
                alert('Processes saved successfully!');
            });
            
            document.getElementById('loadProcesses').addEventListener('click', function() {
                const data = localStorage.getItem('cpuSchedulerProcesses');
                if (!data) {
                    alert('No saved processes found');
                    return;
                }
                
                processes = JSON.parse(data);
                updateProcessTable();
                alert('Processes loaded successfully!');
            });
            
            // Update algorithm details when algorithm changes
            function updateAlgorithmDetails() {
                const algorithm = document.getElementById('algorithm').value;
                const detailsDiv = document.getElementById('algorithmSpecificInfo');
                
                switch (algorithm) {
                    case 'fcfs':
                        detailsDiv.innerHTML = `
                            <h3>Energy-Aware FCFS (First-Come, First-Served)</h3>
                            <p>This modified FCFS algorithm considers both arrival time and energy consumption when scheduling processes. It aims to minimize total energy usage while maintaining fairness.</p>
                            
                            <div class="code-block">
function energyAwareFCFS(processes) {
    // Sort by arrival time (FCFS)
    processes.sort((a, b) => a.arrival - b.arrival);
    
    let currentTime = 0;
    let totalEnergy = 0;
    
    for (let p of processes) {
        // If CPU is idle, fast forward to next arrival
        if (currentTime < p.arrival) {
            currentTime = p.arrival;
        }
        
        // Execute process
        totalEnergy += p.energy * p.burst;
        currentTime += p.burst;
        
        // Record metrics
        p.completion = currentTime;
        p.turnaround = p.completion - p.arrival;
        p.waiting = p.turnaround - p.burst;
    }
    
    return { processes, totalEnergy };
}
                            </div>
                        `;
                        break;
                        
                    case 'dvs':
                        detailsDiv.innerHTML = `
                            <h3>Dynamic Voltage Scaling (DVS)</h3>
                            <p>This algorithm adjusts the CPU voltage and frequency based on the process requirements, reducing energy consumption when full performance isn't needed.</p>
                            
                            <div class="code-block">
function dynamicVoltageScaling(processes) {
    // Sort by arrival time
    processes.sort((a, b) => a.arrival - b.arrival);
    
    let currentTime = 0;
    let totalEnergy = 0;
    
    for (let p of processes) {
        if (currentTime < p.arrival) {
            currentTime = p.arrival;
        }
        
        // Adjust energy based on remaining time
        const energyFactor = Math.min(1, p.remaining / p.burst + 0.2);
        const adjustedEnergy = p.energy * energyFactor;
        
        // Execute process with adjusted energy
        totalEnergy += adjustedEnergy * p.burst;
        currentTime += p.burst;
        
        p.completion = currentTime;
        p.turnaround = p.completion - p.arrival;
        p.waiting = p.turnaround - p.burst;
    }
    
    return { processes, totalEnergy };
}
                            </div>
                        `;
                        break;
                        
                    case 'rr':
                        detailsDiv.innerHTML = `
                            <h3>Energy-Conscious Round Robin</h3>
                            <p>This Round Robin variant considers energy consumption when allocating time quantums, potentially giving more time to energy-efficient processes.</p>
                            
                            <div class="code-block">
function energyConsciousRR(processes, quantum) {
    let currentTime = 0;
    let totalEnergy = 0;
    let queue = [...processes];
    
    while (queue.some(p => !p.completed)) {
        const p = queue.find(p => !p.completed && p.arrival <= currentTime);
        
        if (!p) {
            currentTime++;
            continue;
        }
        
        // Execute for quantum or remaining time
        const executeTime = Math.min(quantum, p.remaining);
        
        // Energy adjustment based on process priority
        const energyFactor = 0.8 + (0.4 * (1 - (p.energy / 20)));
        const adjustedEnergy = p.energy * energyFactor;
        
        totalEnergy += adjustedEnergy * executeTime;
        p.remaining -= executeTime;
        currentTime += executeTime;
        
        if (p.remaining === 0) {
            p.completed = true;
            p.completion = currentTime;
            p.turnaround = p.completion - p.arrival;
            p.waiting = p.turnaround - p.burst;
        }
        
        // Rotate queue
        queue = queue.filter(x => x !== p).concat([p]);
    }
    
    return { processes, totalEnergy };
}
                            </div>
                        `;
                        break;
                        
                    case 'sjf':
                        detailsDiv.innerHTML = `
                            <h3>Power-Saving Shortest Job First</h3>
                            <p>This SJF implementation prioritizes shorter jobs while also considering their energy consumption, aiming to reduce both turnaround time and power usage.</p>
                            
                            <div class="code-block">
function powerSavingSJF(processes) {
    let currentTime = 0;
    let totalEnergy = 0;
    let remaining = processes.map(p => ({ ...p }));
    
    while (remaining.some(p => !p.completed)) {
        // Get arrived, incomplete processes
        const ready = remaining.filter(p => 
            !p.completed && p.arrival <= currentTime
        );
        
        if (ready.length === 0) {
            currentTime++;
            continue;
        }
        
        // Sort by burst time (SJF) and energy consumption
        ready.sort((a, b) => {
            const burstDiff = a.burst - b.burst;
            if (burstDiff !== 0) return burstDiff;
            return a.energy - b.energy;
        });
        
        const p = ready[0];
        
        // Execute process
        totalEnergy += p.energy * p.burst;
        currentTime += p.burst;
        
        p.completed = true;
        p.completion = currentTime;
        p.turnaround = p.completion - p.arrival;
        p.waiting = p.turnaround - p.burst;
    }
    
    return { processes: remaining, totalEnergy };
}
                            </div>
                        `;
                        break;
                        
                    case 'eas':
                        detailsDiv.innerHTML = `
                            <h3>Energy-Aware Scheduling (EAS)</h3>
                            <p>EAS considers both performance and energy efficiency when making scheduling decisions, balancing between throughput and power consumption.</p>
                            
                            <div class="code-block">
function energyAwareScheduling(processes) {
    let currentTime = 0;
    let totalEnergy = 0;
    let remaining = [...processes];
    
    while (remaining.some(p => !p.completed)) {
        // Get arrived, incomplete processes
        const ready = remaining.filter(p => 
            !p.completed && p.arrival <= currentTime
        );
        
        if (ready.length === 0) {
            currentTime++;
            continue;
        }
        
        // Sort by energy efficiency (energy per burst unit)
        ready.sort((a, b) => (a.energy / a.burst) - (b.energy / b.burst));
        
        const p = ready[0];
        
        // Execute process
        totalEnergy += p.energy;
        p.remaining--;
        currentTime++;
        
        if (p.remaining === 0) {
            p.completed = true;
            p.completion = currentTime;
            p.turnaround = p.completion - p.arrival;
            p.waiting = p.turnaround - p.burst;
        }
    }
    
    return { processes: remaining, totalEnergy };
}
                            </div>
                        `;
                        break;
                        
                    case 'dvfs':
                        detailsDiv.innerHTML = `
                            <h3>DVFS Scheduling</h3>
                            <p>Dynamic Voltage and Frequency Scaling adjusts the CPU voltage and frequency based on workload, significantly reducing energy consumption during lighter loads.</p>
                            
                            <div class="code-block">
function dvfsScheduling(processes) {
    let currentTime = 0;
    let totalEnergy = 0;
    let remaining = [...processes];
    
    while (remaining.some(p => !p.completed)) {
        // Get arrived, incomplete processes
        const ready = remaining.filter(p => 
            !p.completed && p.arrival <= currentTime
        );
        
        if (ready.length === 0) {
            currentTime++;
            continue;
        }
        
        // Select process with highest priority (lowest number)
        ready.sort((a, b) => a.priority - b.priority);
        const p = ready[0];
        
        // Adjust energy based on remaining time and priority
        const loadFactor = p.remaining / p.burst;
        const priorityFactor = 1 - (p.priority - 1) / 9;
        const energyFactor = 0.3 + (0.7 * loadFactor * priorityFactor);
        const adjustedEnergy = p.energy * energyFactor;
        
        totalEnergy += adjustedEnergy;
        p.remaining--;
        currentTime++;
        
        if (p.remaining === 0) {
            p.completed = true;
            p.completion = currentTime;
            p.turnaround = p.completion - p.arrival;
            p.waiting = p.turnaround - p.burst;
        }
    }
    
    return { processes: remaining, totalEnergy };
}
                            </div>
                        `;
                        break;
                }
            }
            
            // Initialize
            updateAlgorithmDetails();
            document.getElementById('quantumGroup').style.display = 'none';
        });
    </script>
</body>
</html>
